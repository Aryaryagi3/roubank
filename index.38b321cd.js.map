{"mappings":"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","sources":["./node_modules/jquery-mask-plugin/dist/jquery.mask.js","./node_modules/@parcel/scope-hoisting/lib/helpers.js"],"sourcesContent":["/**\n * jquery.mask.js\n * @version: v1.14.16\n * @author: Igor Escobar\n *\n * Created by Igor Escobar on 2012-03-10. Please report any bug at github.com/igorescobar/jQuery-Mask-Plugin\n *\n * Copyright (c) 2012 Igor Escobar http://igorescobar.com\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* jshint laxbreak: true */\n/* jshint maxcomplexity:17 */\n/* global define */\n\n// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.\n// https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js\n(function (factory, jQuery, Zepto) {\n\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object' && typeof Meteor === 'undefined') {\n        module.exports = factory(require('jquery'));\n    } else {\n        factory(jQuery || Zepto);\n    }\n\n}(function ($) {\n    'use strict';\n\n    var Mask = function (el, mask, options) {\n\n        var p = {\n            invalid: [],\n            getCaret: function () {\n                try {\n                    var sel,\n                        pos = 0,\n                        ctrl = el.get(0),\n                        dSel = document.selection,\n                        cSelStart = ctrl.selectionStart;\n\n                    // IE Support\n                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {\n                        sel = dSel.createRange();\n                        sel.moveStart('character', -p.val().length);\n                        pos = sel.text.length;\n                    }\n                    // Firefox support\n                    else if (cSelStart || cSelStart === '0') {\n                        pos = cSelStart;\n                    }\n\n                    return pos;\n                } catch (e) {}\n            },\n            setCaret: function(pos) {\n                try {\n                    if (el.is(':focus')) {\n                        var range, ctrl = el.get(0);\n\n                        // Firefox, WebKit, etc..\n                        if (ctrl.setSelectionRange) {\n                            ctrl.setSelectionRange(pos, pos);\n                        } else { // IE\n                            range = ctrl.createTextRange();\n                            range.collapse(true);\n                            range.moveEnd('character', pos);\n                            range.moveStart('character', pos);\n                            range.select();\n                        }\n                    }\n                } catch (e) {}\n            },\n            events: function() {\n                el\n                .on('keydown.mask', function(e) {\n                    el.data('mask-keycode', e.keyCode || e.which);\n                    el.data('mask-previus-value', el.val());\n                    el.data('mask-previus-caret-pos', p.getCaret());\n                    p.maskDigitPosMapOld = p.maskDigitPosMap;\n                })\n                .on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)\n                .on('paste.mask drop.mask', function() {\n                    setTimeout(function() {\n                        el.keydown().keyup();\n                    }, 100);\n                })\n                .on('change.mask', function(){\n                    el.data('changed', true);\n                })\n                .on('blur.mask', function(){\n                    if (oldValue !== p.val() && !el.data('changed')) {\n                        el.trigger('change');\n                    }\n                    el.data('changed', false);\n                })\n                // it's very important that this callback remains in this position\n                // otherwhise oldValue it's going to work buggy\n                .on('blur.mask', function() {\n                    oldValue = p.val();\n                })\n                // select all text on focus\n                .on('focus.mask', function (e) {\n                    if (options.selectOnFocus === true) {\n                        $(e.target).select();\n                    }\n                })\n                // clear the value if it not complete the mask\n                .on('focusout.mask', function() {\n                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {\n                       p.val('');\n                   }\n                });\n            },\n            getRegexMask: function() {\n                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;\n\n                for (var i = 0; i < mask.length; i++) {\n                    translation = jMask.translation[mask.charAt(i)];\n\n                    if (translation) {\n\n                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');\n                        optional = translation.optional;\n                        recursive = translation.recursive;\n\n                        if (recursive) {\n                            maskChunks.push(mask.charAt(i));\n                            oRecursive = {digit: mask.charAt(i), pattern: pattern};\n                        } else {\n                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));\n                        }\n\n                    } else {\n                        maskChunks.push(mask.charAt(i).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n                    }\n                }\n\n                r = maskChunks.join('');\n\n                if (oRecursive) {\n                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')\n                         .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);\n                }\n\n                return new RegExp(r);\n            },\n            destroyEvents: function() {\n                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));\n            },\n            val: function(v) {\n                var isInput = el.is('input'),\n                    method = isInput ? 'val' : 'text',\n                    r;\n\n                if (arguments.length > 0) {\n                    if (el[method]() !== v) {\n                        el[method](v);\n                    }\n                    r = el;\n                } else {\n                    r = el[method]();\n                }\n\n                return r;\n            },\n            calculateCaretPosition: function(oldVal) {\n                var newVal = p.getMasked(),\n                    caretPosNew = p.getCaret();\n                if (oldVal !== newVal) {\n                    var caretPosOld = el.data('mask-previus-caret-pos') || 0,\n                        newValL = newVal.length,\n                        oldValL = oldVal.length,\n                        maskDigitsBeforeCaret = 0,\n                        maskDigitsAfterCaret = 0,\n                        maskDigitsBeforeCaretAll = 0,\n                        maskDigitsBeforeCaretAllOld = 0,\n                        i = 0;\n\n                    for (i = caretPosNew; i < newValL; i++) {\n                        if (!p.maskDigitPosMap[i]) {\n                            break;\n                        }\n                        maskDigitsAfterCaret++;\n                    }\n\n                    for (i = caretPosNew - 1; i >= 0; i--) {\n                        if (!p.maskDigitPosMap[i]) {\n                            break;\n                        }\n                        maskDigitsBeforeCaret++;\n                    }\n\n                    for (i = caretPosNew - 1; i >= 0; i--) {\n                        if (p.maskDigitPosMap[i]) {\n                            maskDigitsBeforeCaretAll++;\n                        }\n                    }\n\n                    for (i = caretPosOld - 1; i >= 0; i--) {\n                        if (p.maskDigitPosMapOld[i]) {\n                            maskDigitsBeforeCaretAllOld++;\n                        }\n                    }\n\n                    // if the cursor is at the end keep it there\n                    if (caretPosNew > oldValL) {\n                      caretPosNew = newValL * 10;\n                    } else if (caretPosOld >= caretPosNew && caretPosOld !== oldValL) {\n                        if (!p.maskDigitPosMapOld[caretPosNew])  {\n                          var caretPos = caretPosNew;\n                          caretPosNew -= maskDigitsBeforeCaretAllOld - maskDigitsBeforeCaretAll;\n                          caretPosNew -= maskDigitsBeforeCaret;\n                          if (p.maskDigitPosMap[caretPosNew])  {\n                            caretPosNew = caretPos;\n                          }\n                        }\n                    }\n                    else if (caretPosNew > caretPosOld) {\n                        caretPosNew += maskDigitsBeforeCaretAll - maskDigitsBeforeCaretAllOld;\n                        caretPosNew += maskDigitsAfterCaret;\n                    }\n                }\n                return caretPosNew;\n            },\n            behaviour: function(e) {\n                e = e || window.event;\n                p.invalid = [];\n\n                var keyCode = el.data('mask-keycode');\n\n                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {\n                    var newVal = p.getMasked(),\n                        caretPos = p.getCaret(),\n                        oldVal = el.data('mask-previus-value') || '';\n\n                    // this is a compensation to devices/browsers that don't compensate\n                    // caret positioning the right way\n                    setTimeout(function() {\n                      p.setCaret(p.calculateCaretPosition(oldVal));\n                    }, $.jMaskGlobals.keyStrokeCompensation);\n\n                    p.val(newVal);\n                    p.setCaret(caretPos);\n                    return p.callbacks(e);\n                }\n            },\n            getMasked: function(skipMaskChars, val) {\n                var buf = [],\n                    value = val === undefined ? p.val() : val + '',\n                    m = 0, maskLen = mask.length,\n                    v = 0, valLen = value.length,\n                    offset = 1, addMethod = 'push',\n                    resetPos = -1,\n                    maskDigitCount = 0,\n                    maskDigitPosArr = [],\n                    lastMaskChar,\n                    check;\n\n                if (options.reverse) {\n                    addMethod = 'unshift';\n                    offset = -1;\n                    lastMaskChar = 0;\n                    m = maskLen - 1;\n                    v = valLen - 1;\n                    check = function () {\n                        return m > -1 && v > -1;\n                    };\n                } else {\n                    lastMaskChar = maskLen - 1;\n                    check = function () {\n                        return m < maskLen && v < valLen;\n                    };\n                }\n\n                var lastUntranslatedMaskChar;\n                while (check()) {\n                    var maskDigit = mask.charAt(m),\n                        valDigit = value.charAt(v),\n                        translation = jMask.translation[maskDigit];\n\n                    if (translation) {\n                        if (valDigit.match(translation.pattern)) {\n                            buf[addMethod](valDigit);\n                             if (translation.recursive) {\n                                if (resetPos === -1) {\n                                    resetPos = m;\n                                } else if (m === lastMaskChar && m !== resetPos) {\n                                    m = resetPos - offset;\n                                }\n\n                                if (lastMaskChar === resetPos) {\n                                    m -= offset;\n                                }\n                            }\n                            m += offset;\n                        } else if (valDigit === lastUntranslatedMaskChar) {\n                            // matched the last untranslated (raw) mask character that we encountered\n                            // likely an insert offset the mask character from the last entry; fall\n                            // through and only increment v\n                            maskDigitCount--;\n                            lastUntranslatedMaskChar = undefined;\n                        } else if (translation.optional) {\n                            m += offset;\n                            v -= offset;\n                        } else if (translation.fallback) {\n                            buf[addMethod](translation.fallback);\n                            m += offset;\n                            v -= offset;\n                        } else {\n                          p.invalid.push({p: v, v: valDigit, e: translation.pattern});\n                        }\n                        v += offset;\n                    } else {\n                        if (!skipMaskChars) {\n                            buf[addMethod](maskDigit);\n                        }\n\n                        if (valDigit === maskDigit) {\n                            maskDigitPosArr.push(v);\n                            v += offset;\n                        } else {\n                            lastUntranslatedMaskChar = maskDigit;\n                            maskDigitPosArr.push(v + maskDigitCount);\n                            maskDigitCount++;\n                        }\n\n                        m += offset;\n                    }\n                }\n\n                var lastMaskCharDigit = mask.charAt(lastMaskChar);\n                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {\n                    buf.push(lastMaskCharDigit);\n                }\n\n                var newVal = buf.join('');\n                p.mapMaskdigitPositions(newVal, maskDigitPosArr, valLen);\n                return newVal;\n            },\n            mapMaskdigitPositions: function(newVal, maskDigitPosArr, valLen) {\n              var maskDiff = options.reverse ? newVal.length - valLen : 0;\n              p.maskDigitPosMap = {};\n              for (var i = 0; i < maskDigitPosArr.length; i++) {\n                p.maskDigitPosMap[maskDigitPosArr[i] + maskDiff] = 1;\n              }\n            },\n            callbacks: function (e) {\n                var val = p.val(),\n                    changed = val !== oldValue,\n                    defaultArgs = [val, e, el, options],\n                    callback = function(name, criteria, args) {\n                        if (typeof options[name] === 'function' && criteria) {\n                            options[name].apply(this, args);\n                        }\n                    };\n\n                callback('onChange', changed === true, defaultArgs);\n                callback('onKeyPress', changed === true, defaultArgs);\n                callback('onComplete', val.length === mask.length, defaultArgs);\n                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);\n            }\n        };\n\n        el = $(el);\n        var jMask = this, oldValue = p.val(), regexMask;\n\n        mask = typeof mask === 'function' ? mask(p.val(), undefined, el,  options) : mask;\n\n        // public methods\n        jMask.mask = mask;\n        jMask.options = options;\n        jMask.remove = function() {\n            var caret = p.getCaret();\n            if (jMask.options.placeholder) {\n                el.removeAttr('placeholder');\n            }\n            if (el.data('mask-maxlength')) {\n                el.removeAttr('maxlength');\n            }\n            p.destroyEvents();\n            p.val(jMask.getCleanVal());\n            p.setCaret(caret);\n            return el;\n        };\n\n        // get value without mask\n        jMask.getCleanVal = function() {\n           return p.getMasked(true);\n        };\n\n        // get masked value without the value being in the input or element\n        jMask.getMaskedVal = function(val) {\n           return p.getMasked(false, val);\n        };\n\n       jMask.init = function(onlyMask) {\n            onlyMask = onlyMask || false;\n            options = options || {};\n\n            jMask.clearIfNotMatch  = $.jMaskGlobals.clearIfNotMatch;\n            jMask.byPassKeys       = $.jMaskGlobals.byPassKeys;\n            jMask.translation      = $.extend({}, $.jMaskGlobals.translation, options.translation);\n\n            jMask = $.extend(true, {}, jMask, options);\n\n            regexMask = p.getRegexMask();\n\n            if (onlyMask) {\n                p.events();\n                p.val(p.getMasked());\n            } else {\n                if (options.placeholder) {\n                    el.attr('placeholder' , options.placeholder);\n                }\n\n                // this is necessary, otherwise if the user submit the form\n                // and then press the \"back\" button, the autocomplete will erase\n                // the data. Works fine on IE9+, FF, Opera, Safari.\n                if (el.data('mask')) {\n                  el.attr('autocomplete', 'off');\n                }\n\n                // detect if is necessary let the user type freely.\n                // for is a lot faster than forEach.\n                for (var i = 0, maxlength = true; i < mask.length; i++) {\n                    var translation = jMask.translation[mask.charAt(i)];\n                    if (translation && translation.recursive) {\n                        maxlength = false;\n                        break;\n                    }\n                }\n\n                if (maxlength) {\n                    el.attr('maxlength', mask.length).data('mask-maxlength', true);\n                }\n\n                p.destroyEvents();\n                p.events();\n\n                var caret = p.getCaret();\n                p.val(p.getMasked());\n                p.setCaret(caret);\n            }\n        };\n\n        jMask.init(!el.is('input'));\n    };\n\n    $.maskWatchers = {};\n    var HTMLAttributes = function () {\n        var input = $(this),\n            options = {},\n            prefix = 'data-mask-',\n            mask = input.attr('data-mask');\n\n        if (input.attr(prefix + 'reverse')) {\n            options.reverse = true;\n        }\n\n        if (input.attr(prefix + 'clearifnotmatch')) {\n            options.clearIfNotMatch = true;\n        }\n\n        if (input.attr(prefix + 'selectonfocus') === 'true') {\n           options.selectOnFocus = true;\n        }\n\n        if (notSameMaskObject(input, mask, options)) {\n            return input.data('mask', new Mask(this, mask, options));\n        }\n    },\n    notSameMaskObject = function(field, mask, options) {\n        options = options || {};\n        var maskObject = $(field).data('mask'),\n            stringify = JSON.stringify,\n            value = $(field).val() || $(field).text();\n        try {\n            if (typeof mask === 'function') {\n                mask = mask(value);\n            }\n            return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;\n        } catch (e) {}\n    },\n    eventSupported = function(eventName) {\n        var el = document.createElement('div'), isSupported;\n\n        eventName = 'on' + eventName;\n        isSupported = (eventName in el);\n\n        if ( !isSupported ) {\n            el.setAttribute(eventName, 'return;');\n            isSupported = typeof el[eventName] === 'function';\n        }\n        el = null;\n\n        return isSupported;\n    };\n\n    $.fn.mask = function(mask, options) {\n        options = options || {};\n        var selector = this.selector,\n            globals = $.jMaskGlobals,\n            interval = globals.watchInterval,\n            watchInputs = options.watchInputs || globals.watchInputs,\n            maskFunction = function() {\n                if (notSameMaskObject(this, mask, options)) {\n                    return $(this).data('mask', new Mask(this, mask, options));\n                }\n            };\n\n        $(this).each(maskFunction);\n\n        if (selector && selector !== '' && watchInputs) {\n            clearInterval($.maskWatchers[selector]);\n            $.maskWatchers[selector] = setInterval(function(){\n                $(document).find(selector).each(maskFunction);\n            }, interval);\n        }\n        return this;\n    };\n\n    $.fn.masked = function(val) {\n        return this.data('mask').getMaskedVal(val);\n    };\n\n    $.fn.unmask = function() {\n        clearInterval($.maskWatchers[this.selector]);\n        delete $.maskWatchers[this.selector];\n        return this.each(function() {\n            var dataMask = $(this).data('mask');\n            if (dataMask) {\n                dataMask.remove().removeData('mask');\n            }\n        });\n    };\n\n    $.fn.cleanVal = function() {\n        return this.data('mask').getCleanVal();\n    };\n\n    $.applyDataMask = function(selector) {\n        selector = selector || $.jMaskGlobals.maskElements;\n        var $selector = (selector instanceof $) ? selector : $(selector);\n        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);\n    };\n\n    var globals = {\n        maskElements: 'input,td,span,div',\n        dataMaskAttr: '*[data-mask]',\n        dataMask: true,\n        watchInterval: 300,\n        watchInputs: true,\n        keyStrokeCompensation: 10,\n        // old versions of chrome dont work great with input event\n        useInput: !/Chrome\\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),\n        watchDataMask: false,\n        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],\n        translation: {\n            '0': {pattern: /\\d/},\n            '9': {pattern: /\\d/, optional: true},\n            '#': {pattern: /\\d/, recursive: true},\n            'A': {pattern: /[a-zA-Z0-9]/},\n            'S': {pattern: /[a-zA-Z]/}\n        }\n    };\n\n    $.jMaskGlobals = $.jMaskGlobals || {};\n    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);\n\n    // looking for inputs with data-mask attribute\n    if (globals.dataMask) {\n        $.applyDataMask();\n    }\n\n    setInterval(function() {\n        if ($.jMaskGlobals.watchDataMask) {\n            $.applyDataMask();\n        }\n    }, globals.watchInterval);\n}, window.jQuery, window.Zepto));\n","var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n"],"names":["factory","jQuery","Zepto","globalThis","self","window","global","$","Mask","el","mask","options","p","invalid","getCaret","sel","pos","ctrl","get","dSel","document","selection","cSelStart","selectionStart","navigator","appVersion","indexOf","createRange","moveStart","val","length","text","e","setCaret","is","range","setSelectionRange","createTextRange","collapse","moveEnd","select","events","on","data","keyCode","which","maskDigitPosMapOld","maskDigitPosMap","jMaskGlobals","useInput","behaviour","setTimeout","keydown","keyup","oldValue","trigger","selectOnFocus","target","clearIfNotMatch","regexMask","test","getRegexMask","translation","pattern","optional","recursive","oRecursive","r","maskChunks","i","jMask","charAt","toString","replace","push","digit","join","RegExp","destroyEvents","off","v","isInput","method","arguments","calculateCaretPosition","oldVal","newVal","getMasked","caretPosNew","caretPosOld","newValL","oldValL","maskDigitsBeforeCaret","maskDigitsAfterCaret","maskDigitsBeforeCaretAll","maskDigitsBeforeCaretAllOld","caretPos","event","inArray","byPassKeys","keyStrokeCompensation","callbacks","skipMaskChars","lastMaskChar","check","lastUntranslatedMaskChar","buf","value","undefined","m","maskLen","valLen","offset","addMethod","resetPos","maskDigitCount","maskDigitPosArr","reverse","maskDigit","valDigit","match","fallback","lastMaskCharDigit","mapMaskdigitPositions","maskDiff","changed","defaultArgs","callback","name","criteria","args","apply","this","remove","caret","placeholder","removeAttr","getCleanVal","getMaskedVal","init","onlyMask","extend","attr","maxlength","maskWatchers","HTMLAttributes","input","prefix","notSameMaskObject","field","maskObject","stringify","JSON","fn","selector","globals","interval","watchInterval","watchInputs","maskFunction","each","clearInterval","setInterval","find","masked","unmask","dataMask","removeData","cleanVal","applyDataMask","maskElements","filter","dataMaskAttr","eventName","isSupported","userAgent","createElement","setAttribute","watchDataMask","A","S","Meteor"],"version":3,"file":"index.38b321cd.js.map"}